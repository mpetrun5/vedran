package cmd

import (
	"crypto/tls"
	"crypto/x509"
	"errors"
	"fmt"
	"github.com/NodeFactoryIo/vedran/internal/loadbalancer"
	"github.com/NodeFactoryIo/vedran/pkg/logger"
	"github.com/NodeFactoryIo/vedran/pkg/util/random"
	tunnel "github.com/mmatczuk/go-http-tunnel"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"io/ioutil"
)

var (
	// load balancer related flags
	authSecret string
	name       string
	capacity   int64
	whitelist  []string
	fee        float32
	selection  string
	port       int32
	// logging related flags
	logLevel string
	logFile  string
)

var startCmd = &cobra.Command{
	Use:   "start",
	Short: "Starts vedran load balancer",
	Run:   startCommand,
	PreRunE: func(cmd *cobra.Command, args []string) error {
		level, err := log.ParseLevel(logLevel)
		if err != nil {
			log.Fatalf("Invalid log level %s", logLevel)
		}
		err = logger.SetupLogger(level, logFile)
		if err != nil {
			return err
		}
		return nil
	},
	Args: func(cmd *cobra.Command, args []string) error {
		// valid values are round-robin and random
		if selection != "round-robin" && selection != "random" {
			return errors.New("invalid selection option selected")
		}
		// all positive integers are valid, and -1 representing unlimited capacity
		if capacity < -1 {
			return errors.New("invalid capacity value")
		}
		// valid value is between 0-1
		if fee < 0 || fee > 1 {
			return errors.New("invalid fee value")
		}
		// well known ports and registered ports
		if port <= 0 && port > 49151 {
			return errors.New("invalid port number")
		}
		return nil
	},
}

func init() {
	startCmd.Flags().StringVar(
		&authSecret,
		"auth-secret",
		"",
		"[REQUIRED] Authentication secret used for generating tokens")

	startCmd.Flags().StringVar(
		&name,
		"name",
		fmt.Sprintf("load-balancer-%s", random.String(12, random.Alphabetic)),
		"[OPTIONAL] Public name for load balancer, autogenerated name used if omitted")

	startCmd.Flags().Int64Var(
		&capacity,
		"capacity",
		-1,
		"[OPTIONAL] Maximum number of nodes allowed to connect, where -1 represents no upper limit")

	startCmd.Flags().StringSliceVar(
		&whitelist,
		"whitelist",
		nil,
		"[OPTIONAL] Comma separated list of node id-s, if provided only these nodes will be allowed to connect")

	startCmd.Flags().Float32Var(
		&fee,
		"fee",
		0.1,
		"[OPTIONAL] Value between 0-1 representing fee percentage")

	startCmd.Flags().StringVar(
		&selection,
		"selection",
		"round-robin",
		"[OPTIONAL] Type of selection used for choosing nodes")

	startCmd.Flags().Int32Var(
		&port,
		"port",
		4000,
		"[OPTIONAL] Port on which load balancer will be started")

	startCmd.Flags().StringVar(
		&logLevel,
		"log-level",
		"error",
		"[OPTIONAL] Level of logging (eg. info, warn, error)")

	startCmd.Flags().StringVar(
		&logFile,
		"log-file",
		"",
		"[OPTIONAL] Path to logfile (default stdout)")

	RootCmd.AddCommand(startCmd)
}

func startCommand(_ *cobra.Command, _ []string) {

	// http tunnel
	tlsConfig, err := tlsConfig("server.crt", "server.key", "")
	if err == nil {
		// create http tunnel
		server, err := tunnel.NewServer(&tunnel.ServerConfig{
			Addr:          ":5223",
			AutoSubscribe: false,
			TLSConfig: tlsConfig,
			SNIAddr:       "",
		})

		// starts http tunnel in new goroutine
		if err == nil {
			log.Debug("Starting http tunel")
			go server.Start()
		} else {
			log.Error(err)
		}
	} else {
		log.Error(err)
	}


	loadbalancer.StartLoadBalancerServer(loadbalancer.Properties{
		AuthSecret: authSecret,
		Name:       name,
		Capacity:   capacity,
		Whitelist:  whitelist,
		Fee:        fee,
		Selection:  selection,
		Port:       port,
	})
}

func tlsConfig(tlsCrt string, tlsKey string, rootCA string) (*tls.Config, error) {
	// load certs
	cert, err := tls.LoadX509KeyPair(tlsCrt, tlsKey)
	if err != nil {
		return nil, err
	}

	// load root CA for client authentication
	clientAuth := tls.RequireAnyClientCert
	var roots *x509.CertPool
	if rootCA != "" {
		roots = x509.NewCertPool()
		rootPEM, err := ioutil.ReadFile(rootCA)
		if err != nil {
			return nil, err
		}
		if ok := roots.AppendCertsFromPEM(rootPEM); !ok {
			return nil, err
		}
		clientAuth = tls.RequireAndVerifyClientCert
	}

	return &tls.Config{
		Certificates:           []tls.Certificate{cert},
		ClientAuth:             clientAuth,
		ClientCAs:              roots,
		SessionTicketsDisabled: true,
		MinVersion:             tls.VersionTLS12,
		CipherSuites: []uint16{
			tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256},
		PreferServerCipherSuites: true,
		NextProtos:               []string{"h2"},
	}, nil
}
